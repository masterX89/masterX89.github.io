<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo - Next 主题添加搜索功能]]></title>
    <url>%2F2019%2F03%2F10%2Fhexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[参考自Yaya’s blog添加Hexo搜索功能 安装相关插件首先安装搜索插件： hexo-generator-searchdb 在hexo路径文件夹下执行： 1$ npm install hexo-generator-searchdb --save 配置hexo安装完成，在hexo的配置文件_config.yml中添加： 12345search: path: search.xml field: post format: html limit: 10000 配置主题Next 主题自带搜索设置，编辑主题配置文件：_config.yml 找到文件中 Local search 的相关配置，设为 true 123# Local searchlocal_search: enable: true hexo 重新部署1$ hexo d -g]]></content>
      <categories>
        <category>hero</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的async/await浅析（一）]]></title>
    <url>%2F2019%2F03%2F09%2FJavaScript%E4%B8%AD%E7%9A%84async-await%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[async/await正式纳入ES7标准之中，给JavaScript的异步编程带来了许多的便利。首先介绍一下async/await的使用场景（大部分情况是由于promise链式带来的不便利）： 多个promise的then链，后续的步骤需要之前的每一个步骤的结果 在循环中需要异步获取数据，循环外异步设置状态 什么是promise从开头的场景就可以知道，使用async/await大部分情况是由于Promise在解决某些需求的时候力不从心了，那么我们就需要先了解Promise，这里是MDN的Promise定义和使用Promise，在理解Promise可以胜任的场景之后，再引入async/await的优点。 Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 Promise 本质上是一个绑定了回调的对象，而不是将回调传进函数内部。 首先我们设计一个业务场景，需求中task1从服务器异步获取数据，然后再传递给task2完成任务。代码如下： 12345678910function task1() &#123; setTimeout(() =&gt; console.log('task1 take too longtime'), 1000);&#125;function task2()&#123; console.log('this is task2');&#125;task1();task2(); 然而输出结果却如下： 12this is task2task1 take too longtime 如果在实际场景中，task2的参数就会为undefined，原因是由于task1是异步函数调用，那么我们如果想要这两个task顺序执行应该怎么办呢？在这里引入Promise的约定： 在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。 通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用。 通过多次调用 .then，可以添加多个回调函数，它们会按照插入顺序并且独立运行。 从上述的约定可以看出，Promise最好的应用场景就是链式调用。 链式调用还是上一个业务场景，这次我们用Promise的then链来解决这个异步函数调用的问题： 12345678910111213141516function task1() &#123; return new Promise(resolve =&gt;&#123; setTimeout(() =&gt; &#123; console.log('task1 take too longtime'); resolve(); &#125;, 1000); &#125;)&#125;function task2()&#123; console.log('this is task2');&#125;task1().then(() =&gt; &#123; task2();&#125;); 最终结果如下： 12task1 take too longtimethis is task2 同时Promise可不是仅仅.then一次，所谓的链式调用即是可以形成一个then链，理论上可以一直then来将异步函数顺序地执行下去，如下面的业务场景共有三个任务，需要顺序执行，分别消耗100，200，300ms的时间： 123456789101112131415161718192021222324252627282930313233function task1(time) &#123; console.log(`task1 take $&#123;time&#125; ms`); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(), time); &#125;);&#125;function task2(time) &#123; console.log(`task2 take $&#123;time&#125; ms`); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(), time); &#125;);&#125;function task3(time) &#123; console.log(`task3 take $&#123;time&#125; ms`); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(), time); &#125;);&#125;function finalTask()&#123; console.time('finalTask'); const time1 = 100, time2 = 200, time3 = 300;//三个任务分别模拟100，200，300ms task1(time1) .then(()=&gt;task2(time2)) .then(()=&gt;task3(time3)) .then(()=&gt;&#123; console.timeEnd('finalTask'); &#125;)&#125;finalTask(); 最后的结果如下： 1234task1 take 100 mstask2 take 200 mstask3 take 300 msfinalTask: 626.755ms 可以看到三个任务是顺序执行的，并且消耗的时间与计时器的时间相差无几。 链式调用传参设计场景中一个常见的需求就是连续执行两个或者多个异步操作，并且每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。下面演示promise链式传递参数： 1234567891011121314151617function task1() &#123; return new Promise(resolve =&gt;&#123; setTimeout(() =&gt; &#123; console.log('task1 take too longtime'); resolve('this is task1 data'); &#125;, 1000); &#125;)&#125;function task2(data)&#123; console.log('this is task2'); console.log(data);&#125;task1().then((data) =&gt; &#123; task2(data);&#125;); 最后结果如下： 123task1 take too longtimethis is task2this is task1 data 可以看到任务1和2还是顺序执行的，并且在任务2中，拿到了任务1传递来的参数，这个参数通过任务1中的resolve函数传递给下一个异步函数。每一个 Promise 代表了链式中另一个异步过程的完成。 Catch的后续链式调用但是在很多场景中，可能存在需要catch error的情况，比如服务器宕机了，或者甚至服务器传来不正确的json数据（笔者就遇到了这种情况，json格式错误，但是前端可以通过字符串操作来纠正并解析数据，然而每次异步获取数据都会走catch）。在这种场景下，首先要明确一点，catch之后是可以继续链式调用promise的，同时catch中可以对数据处理并传递给下一个函数，代码如下： 12345678910111213141516new Promise((resolve, reject) =&gt; &#123; console.log('Initial'); resolve();&#125;).then(() =&gt; &#123; throw new Error('Something failed'); console.log('Do this');&#125;).catch(() =&gt; &#123; console.log('Do that'); return 'error text';&#125;).then((data) =&gt; &#123; console.log(data); console.log('Do this whatever happened before');&#125;); 最后的执行结果如下： 1234InitialDo thaterror textDo this whatever happened before 对这个结果进行分析，可以看出异步函数是链式顺序执行的，其中“Do this”方法中由于抛出一个Error，所以没有输出“Do this”。接着catch方法中正确执行，并且假设“error text”为处理后的结果，是可以顺利传递给下一个方法的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio常用快捷键]]></title>
    <url>%2F2016%2F05%2F25%2FAndroid%20Studio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[最近开始尝试转向Android Studio开发了，于是总结一下常用的快捷键。顺带着粘一段wikipedia上as的简介凑字数。 Android Studio是一个为Android平台开发程序的集成开发环境。2013年5月16日在Google I/O上发布，可供开发者免费使用。2013年5月发布早期预览版本，版本号为0.1。2014年6月发布0.8版本，至此进入beta阶段。第一个稳定版本1.0于2014年12月8日发布。Android Studio基于JetBrains IntelliJ IDEA，为Android开发特殊定制，并在Windows、OS X和Linux平台上均可运行。 本篇适用于日常使用，详细快捷键请参考此篇AndroidStudio快捷键汇总 重构-重命名 Shift + F6这个很重要 提取局部变量 Ctrl(Command) + Alt(Option) + V 提取全局变量 Ctrl(Command) + Alt(Option) + F 快速修复 Alt(Option) + Enter(用于类型强转等快速修复，不可以用于提取全局变量，和eclipse不一样) 全屏当前标签页 Ctrl(Command) + Shift + F12 撤销(undo) Ctrl(Command) + Z 重做(redo) Ctrl(Command) + Shift + Z 格式化代码 Ctrl(Command) + Alt(Option) + L 折叠代码 Ctrl(Command) + . 方法参数提示 Ctrl(Command) + P 显示注释文档 Ctrl(Command) + Q 生成构造器、Getter、Setter Alt(Option) + Insert 块选中 Alt(Option) + J（解放Ctrl(Command) + LEFT/RIGHT的福音） 自动代码 Ctrl(Command) + J 查询当前元素在工程中的引用 Alt(Option) + F7 方法间快速跳转 Alt(Option) + UP(DOWN) 标签页间相互跳转 Alt(Option) + LEFT(RIGHT) 重写方法 Ctrl(Command) + O 代码上下移动 Alt(Option) + Shift + UP(DOWN) 打开设置对话框 Ctrl(Command) + Alt(Option) + S 打开当前项目/模块属性 Ctrl(Command) + Shift + Alt(Option) + S 多行编辑 Alt + 鼠标滑选]]></content>
      <categories>
        <category>Android Studio</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析WinDLX及其实战]]></title>
    <url>%2F2016%2F04%2F23%2F%E6%B5%85%E6%9E%90WinDLX%E5%8F%8A%E5%85%B6%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[WinDLX简介 WinDLX模拟器是一个基于Windows操作系统的图形化、交互式DLX指令集模拟器，能够演示DLX指令集流水线是如何工作的。该模拟器可以装载DLX汇编语言程序（后缀为“.s”的文件），然后单步、设断点或是连续执行该程序。CPU的寄存器、流水线、I/O和存储器都用图形进行表示，以形象生动的方式描述DLX流水线的工作过程。模拟器还提供了对流水线操作的统计功能，便于对流水线进行性能分析。 环境配置 主要运行在win3.0上，16bit软件，不支持64bit系统。所以在使用前需要确保系统环境为32bit，方可兼容此软件，否则需要虚拟机环境。 为WinDLX创建目录，例如D:\WINDLX，注意受编译的约束，路径名中不可以包含汉字。 解压WinDLX软件包或拷贝所有的WinDLX文件（至少包含 windlx.exe，windlx.hlp，fact.s 和input.s ）到这个WinDLX 目录。 WinDLX子窗口Pipeline IF取指阶段 ID译码阶段 MEM访存阶段 WB写回阶段 intEX整型加阶段执行 faddEX浮点加执行阶段 fmul浮点乘执行阶段 fdivEX浮点除执行阶段 Code 三栏信息，从左到右依次为：地址 (符号或数字)、命令的十六进制机器代码和汇编命令。 按下 F7 键，模拟就向前执行一步，第一行的颜色变成黄色，下一行变成棕色，依次向下执行。 Clock Cycle Diagram 横坐标代表时钟周期，纵坐标为指令集 Breakpoint 此为增设断点的子窗口 Register 此为寄存器的子窗口 Statistics 分析窗口，主要关注RAW stall数据相关，Structral stall结构相关，Control stall控制相关。 下文中会主要分析这三者的产生原因及其消除方法。 WinDLX指令分类 Load/Store指令：除R0之外，所有通用寄存器与浮点寄存器都可以作为加载或存储之用 ALU操作指令：所有的ALU操作都是寄存器–寄存器指令。加，减，与，或，异或，移位，比较指令比较两个寄存器(=, !=, &lt;, &gt;, =&lt;, =&gt;)，如果条件为真，则在目标寄存器置1，否则置0。 分支/跳转指令：所有分支都是条件分支，分支条件由指令测试寄存器为零或非零来指定。 浮点运算指令：浮点加，减，乘，除(浮点格式为IEEE754) Trap机制 Trap在DLX程序和系统I/O之间建立了接口。在WinDLX中共定义了5种Trap。 0对于Trap指令来说是无效参数，Trap 0用来结束程序 Trap 1可以为读写打开一个文件，打开的文件在DLX重置或结束之后自动关闭 Trap 2关闭由Trap 1打开的文件 Trap 3从文件块读，读入一个文件块或者标准输入的一行 Trap 4向文件块写，向文存储器或标准输出块写 实例讲解程序说明功能：卡特兰数求解输入：输入一个大于0的自然数n，程序会计算第n项的卡特兰数 测试用例： 输入:n=7 输出：132 卡特兰数讲解 一般公式 $$ C_n = \frac{1}{n+1} \dbinom{2n}{n} = \frac{(2n)!}{(n+1)!n!} $$ 递推公式 它也满足 卡塔兰数的渐近增长为 前20项为（OEIS中的数列A000108）：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190 样例程序求解第n项卡特兰数的WinDLX样例程序 ;*********** WINDLX Ex.3: Factorial ************* ;*********** (c) 1991 Günther Raidl ************* ;*********** Modified: 1992 Maziar Khosravipour ************* ; class: ; number: ; author: ;-------------------------------------------------------------------------- ; Program begin at symbol main ; requires module INPUT ; read a number from stdin and calculate the catalan number (type: double) ; the result is written to stdout ;-------------------------------------------------------------------------- .data Prompt: .asciiz &quot;An integer value &gt;1 : &quot; PrintfFormat: .asciiz &quot;Factorial = %g\n\n&quot; .align 2 PrintfPar: .word PrintfFormat PrintfValue: .space 1024 .text .global main main: ;*** Read value from stdin into R1 addi r1,r0,Prompt jal InputUnsigned ;*** init values subi r1,r1,1 movi2fp f10,r1 ;R1 -&gt; D0 D0..Count register cvti2d f0,f10 addi r2,r0,1 ;1 -&gt; D2 D2..result movi2fp f11,r2 cvti2d f2,f11 movd f4,f2 ;1-&gt; D4 D4..Constant 1 addd f6,f0,f4 ;D0+1 -&gt; D6 addd f8,f0,f0 ;2*D0 -&gt; D8 addi r2,r0,1 ;1 -&gt; D10 D10..result movi2fp f11,r2 cvti2d f10,f11 ;*** Break loop if D0 = 1 Loop1: led f0,f4 ;D0&lt;=1 ? bfpt Loop2 ;*** Multiplication and next loop1 multd f2,f2,f0 subd f0,f0,f4 j Loop1 ;*** Break loop if D8 = 1 Loop2: led f8,f4 ;D8&lt;=1 ? bfpt Finish ;*** Multiplication and next loop2 multd f10,f10,f8 subd f8,f8,f4 ;multd f10,f10,f8 ;subd f8,f8,f4 ;multd f10,f10,f8 ;subd f8,f8,f4 ;multd f10,f10,f8 ;subd f8,f8,f4 j Loop2 Finish: ;*** write result to stdout multd f2,f2,f2 multd f6,f6,f2 divd f10,f10,f6 sd PrintfValue,f10 addi r14,r0,PrintfPar trap 5 ;*** end trap 0 三种相关 数据相关：当一条指令需要用到前面指令的执行结果，而这些指令均在流水线中重叠执行时 结构相关：当指令在重叠执行过程中，硬件资源满足不了指令重叠执行的要求,发生资源冲突时 控制相关：当不满足条件时或者其他改变PC值的跳转指令，通常发生控制相关 消除方法 数据相关：勾选Enable Forwading，采用重定向技术 结构相关：通过增加硬件的数目来解决结构相关 控制相关：为了解决控制相关，我们要在分支跳转指令里循环展开，通过代码的冗余来做到消除控制相关]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>WinDLX</tag>
        <tag>指令集流水线</tag>
      </tags>
  </entry>
</search>
