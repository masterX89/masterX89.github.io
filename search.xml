<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则表达式（二）]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[正则表达式（二）—常用表达式检验文件后缀名1234567891011export const fileOpt = &#123; isEditableFilePattern: /\.(txt|diff?|patch|svg|asc|cnf|cfg|conf|html?|.html|cfm|cgi|aspx?|ini|pl|py|md|css|cs|js|jsp|log|htaccess|htpasswd|gitignore|gitattributes|env|json|atom|eml|rss|markdown|sql|xml|xslt?|sh|rb|as|bat|cmd|cob|for|ftn|frm|frx|inc|lisp|scm|coffee|php[3-6]?|java|c|cbl|go|h|scala|vb|tmpl|lock|go|yml|yaml|tsv|lst)$/i, isViewableFilePattern: /\.(doc|docm|docx|dot|dotm|dotx|odt|odp|pot|potm|potx|pps|ppsm|ppsx|ppt|pptm|pptx|ods|xls|xlsb|xlsm|xlsx|pdf|one|onetoc2?)$/i, isImageFilePattern: /\.(jpe?g|gif|bmp|png|svg|tiff?|ico|pcx)$/i, isExtractableFilePattern: /\.(gz|tar|rar|g?zip)$/i, officeWordTypePattern: /\.(doc|docm|docx|dot|dotm|dotx|odt?)$/i, officePptTypePattern: /\.(odp|pot|potm|potx|pps|ppsm|ppsx|ppt|pptm|pptx?)$/i, officeExcelTypePattern: /\.(ods|xls|xlsb|xlsm|xlsx?)$/i, pdfTypePattern: /\.(pdf?)$/i, officeOneNoteTypePattern: /\.(one|onetoc2?)$/i&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（一）]]></title>
    <url>%2F2019%2F08%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[正则表达式（一）基础知识 本章节转载自：javascript 总结（RegExp篇） 作者：咚子 发布时间：2018-01-04 修饰符 i: 执行对大小写不敏感的匹配。 g: 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m: 执行多行匹配。 元字符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118\d: 匹配一个数字字符。等价于 [0-9]。\D: 匹配一个非数字字符。等价于 [^0-9]。\f: 匹配一个换页符。等价于 \x0c 和 \cL。\n: 匹配一个换行符。等价于 \x0a 和 \cJ。\r: 匹配一个回车符。等价于 \x0d 和 \cM。\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。\S: 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。\t: 匹配一个制表符。等价于 \x09 和 \cI。\v: 匹配一个垂直制表符。等价于 \x0b 和 \cK。\w: 匹配字母、数字、下划线。等价于&apos;[A-Za-z0-9_]&apos;。\W: 匹配非字母、数字、下划线。等价于 &apos;[^A-Za-z0-9_]&apos;。\xn: 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。 例: &apos;\x41&apos; 匹配 &quot;A&quot;。&apos;\x041&apos; 则等价于 &apos;\x04&apos; &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码。\num: 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。 例: &apos;(.)\1&apos; 匹配两个连续的相同字符。\n: 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。\nm: 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm\nml: 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml\un: 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。 例: \u00A9 匹配版权符号 (?)。 \: 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。 例:&apos;n&apos; 匹配字符 &quot;n&quot;。&apos;\n&apos; 匹配一个换行符。序列 &apos;\\&apos; 匹配 &quot;\&quot; 而 &quot;\(&quot; 则匹配 &quot;(&quot;。^: 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 &apos;\n&apos; 或 &apos;\r&apos; 之后的位置。 例： (^a) 就是匹配以字母a开头的字符串^: 还有另个一个作用就是取反，比如[^xyz] 表示匹配的字符串不包含xyz 例： [^xyz] 表示匹配的字符串不包含xyz$: 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 &apos;\n&apos; 或 &apos;\r&apos; 之前的位置。 例： (b$) 就是匹配以字母b结尾的字符串*: 匹配前面的子表达式零次或多次。 例: zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于&#123;0,&#125;。+: 匹配前面的子表达式一次或多次。 例: &apos;zo+&apos; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 &#123;1,&#125;。?: 匹配前面的子表达式零次或一次。 例: &quot;do(es)?&quot; 可以匹配 &quot;do&quot; 或 &quot;does&quot; 。? 等价于 &#123;0,1&#125;。?: 当该字符紧跟在任何一个其他限制符 (*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 例: 对于字符串 &quot;oooo&quot;，&apos;o+?&apos; 将匹配单个 &quot;o&quot;，而 &apos;o+&apos; 将匹配所有 &apos;o&apos;。&#123;n&#125;: n 是一个非负整数。匹配确定的 n 次。 例: &apos;o&#123;2&#125;&apos; 不能匹配 &quot;Bob&quot; 中的 &apos;o&apos;，但是能匹配 &quot;food&quot; 中的两个 o&#123;n,&#125;: n 是一个非负整数。至少匹配n 次。 例: &apos;o&#123;2,&#125;&apos; 不能匹配 &quot;Bob&quot; 中的 &apos;o&apos;，但能匹配 &quot;foooood&quot; 中的所有 o。&apos;o&#123;1,&#125;&apos; 等价于 &apos;o+&apos;。&apos;o&#123;0,&#125;&apos; 则等价于 &apos;o*&apos;。&#123;n,m&#125;: m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 例: &quot;o&#123;1,3&#125;&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&apos;o&#123;0,1&#125;&apos; 等价于 &apos;o?&apos;。请注意在逗号和两个数之间不能有空格。.: 匹配除 &quot;\n&quot; 之外的任何单个字符。要匹配包括 &apos;\n&apos; 在内的任何字符，请使用像&quot;(.|\n)&quot;的模式。(pattern): 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 &apos;\(&apos; 或 &apos;\)&apos; 例：&quot;(x)&quot; 将匹配到 &quot;x&quot; 并将按顺序从 $1-$99 排序代替 例： var url = &quot;http://www.qidian.com/BookReader/1017141,20361055.aspx&quot; var reg = /(http:\/\/www\.qidian\.com\/BookReader\/)(\d+),(\d+).aspx/gmi var rep=url.replace(reg,&quot;$1ShowBook.aspx?bookId=$2&amp;chapterId=$3&quot;); console.log(rep); // -&gt; http://www.qidian.com/BookReader/ShowBook.aspx?bookId=1017141&amp;chapterId=20361055(?:pattern)：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 &quot;或&quot; 字符 (|) 来组合一个模式的各个部分是很有用。 例：&apos;industr(?:y|ies) 就是一个比 &apos;industry|industries&apos; 更简略的表达式。(?=pattern): 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 例: &quot;Windows(?=95|98|NT|2000)&quot;能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern): 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 例: &quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?&lt;=pattern): 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。 例: &quot;(?&lt;=95|98|NT|2000)Windows&quot;能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;。(?&lt;!pattern): 反向否定预查，与正向否定预查类似，只是方向相反。 例: &quot;(?&lt;!95|98|NT|2000)Windows&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;。x|y: 匹配 x 或 y。 例: &apos;z|food&apos; 能匹配 &quot;z&quot; 或 &quot;food&quot;。&apos;(z|f)ood&apos; 则匹配 &quot;zood&quot; 或 &quot;food&quot;。[xyz]: 字符集合。匹配所包含的任意一个字符。 例: &apos;[abc]&apos; 可以匹配 &quot;plain&quot; 中的 &apos;a&apos;。[^xyz]: 负值字符集合。匹配未包含的任意字符。 例: &apos;[^abc]&apos; 可以匹配 &quot;plain&quot; 中的&apos;p&apos;、&apos;l&apos;、&apos;i&apos;、&apos;n&apos;。[a-z]: 字符范围。匹配指定范围内的任意字符。 例: &apos;[a-z]&apos; 可以匹配 &apos;a&apos; 到 &apos;z&apos; 范围内的任意小写字母字符。[^a-z]: 负值字符范围。匹配任何不在指定范围内的任意字符。 例: &apos;[^a-z]&apos; 可以匹配任何不在 &apos;a&apos; 到 &apos;z&apos; 范围内的任意字符。\b: 匹配一个单词边界，也就是指单词和空格间的位置。 例: &apos;er\b&apos; 可以匹配&quot;never&quot; 中的 &apos;er&apos;，但不能匹配 &quot;verb&quot; 中的 &apos;er&apos;。\B: 匹配非单词边界。 例: &apos;er\B&apos; 能匹配 &quot;verb&quot; 中的 &apos;er&apos;，但不能匹配 &quot;never&quot; 中的 &apos;er&apos;。\cx: 匹配由 x 指明的控制字符。 例: \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 &apos;c&apos; 字符。 方法 compile(regexp,modifier): 在脚本执行过程中编译正则表达式 1234567891011121314/* regexp: 正则表达式 modifier: 规定匹配的类型。"g" 用于全局匹配，"i" 用于区分大小写，"gi" 用于全局区分大小写的匹配。*/var compileStr = "Every man in the world! Every woman on earth!";var compilePatt = /man/g;var compilePatt1 = /(wo)?man/g;compilePatt1.compile(compilePatt1) var compileStrEle1 = compileStr.replace(compilePatt,"person");var compileStrEle2 = compileStr.replace(compilePatt1,"person"); console.log(compileStrEle1) // -&gt; Every person in the world! Every woperson on earth!console.log(compileStrEle2) // -&gt; Every person in the world! Every person on earth! exec(string): 用于检索字符串中的正则表达式的匹配。如果字符串中有匹配的值返回该匹配值，否则返回 null。 1234var execStr = "Hello world!";var execPatt = /Hello/g;var execStrEle = execPatt.exec(execStr);console.log(execStrEle) // -&gt; Hello test(string): 用于检测一个字符串是否匹配某个模式.如果字符串中有匹配的值返回 true ，否则返回 false 123456789var testStr = "Hello world!";var testPatt = /Hello/g;var testPatt2 = /Helloaaa/g; var testStrEle = testPatt.test(testStr);var testStrEle2 = testPatt2.test(testStr); console.log(testStrEle) // -&gt; trueconsole.log(testStrEle2) // -&gt; false match(regexp): 可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 1234var matchStr = "The rain in SPAIN stays mainly in the plain"; var matchEle = matchStr.match(/ain/gi);console.log(matchEle)// -&gt; ["ain", "AIN", "ain", "ain"]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[console.log的小坑]]></title>
    <url>%2F2019%2F04%2F17%2Fconsole.log%E7%9A%84%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[兼听则明，偏信则暗 最近在写代码的时候，遇到了一个问题，很有趣所以要把这个现象记录下来。我在console.log里获取到的数值，会因为我后面调用的组件而改变，导致我debug的时候一直没有正确地定位到真正发生错误的地方，吃一堑长一智，以后在chrome里debug，不仅要使用console.log，以后还要使用断点调试。 问题描述这个问题是这样的，我在异步获取到服务器的数据后，我使用了一个甘特图的组件来初始化另一个数据。伪代码大概如下： 12345get(url).then(data=&gt;&#123; console.log(data); let tempdata=&#123;...data,links:[]&#125;; gantt.prom(tempdata);&#125;) 然后我获取到的data一直是错误的，导致我一直以为是服务器端写错的问题。但是在服务器端打了断点，从数据库中获取到数据后，在服务器端的数据流里，变量一直是正确的，然后到了前端里，console.log后就是错误的。 问题解决后来在同学的帮助下，先在console.log处打了断点，然后发现此时的data还是正确的。然后到了gantt.prom(tempdata)这句话后，data就变成了错误的数据。可以猜想到，这个控件会处理我组件里所有的数据结构，但是一开始没有想到是后面的语句修改了前面的数据数值。 问题分析那么为什么console.log会发生这种现象呢？我在控制台里输入这样的语句： 123let obj=&#123;id:1&#125;;console.log(obj);obj.id=110; 在chrome的控制台里会出现这个语句： 1&#123;id: 1&#125; 这个和预想的是一样的，但是当我展开的时候，控制台就是这样的情况： 123&#123;id: 1&#125;id: 110__proto__: Object 也就是说，id确实被改变了。即使控制台已经输出了，但是当展开的一瞬间，会指向新的对象，然后获取到当前对象的数值。产生这个现象的原因就是我打印的是一个对象，是一个引用，当我第一次打印的时候，数值还没有变化，而当我修改后展开这个对象，引用会指向对象，然后获取到新的数值。 但是我还是没有明白为什么gantt这个控件这么强大，可以修改我在react里的数据的属性，强行修改成他所需要的格式，即便是我传递给他的参数并不是data。我一开始分析是由于我的…解析了data放在了tempdata里面，但是后来在试验里发现并不会由于…的解析数据导致原数据的变化。所以gantt修改数据我还是没有明白，但是console.log这一现象还是值得我在以后的生涯中注意的。而且也意识到了断点的好处，断点即使是在异步里，也可以完美的执行我所想要的顺序。并且可以避免这种调用了一个控件，偷偷在后面的步骤中，修改了之前的数值，导致我log出错的情况。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米秋招面试题题解]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%B0%8F%E7%B1%B3%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目描述今天同学分享了一个小米面试题，题目描述在牛客网上可以看到。这里将题目描述重述一下： 在游戏Dota2中，有一位非常强大的英雄卡尔，他有三种属性：冰、火、雷。同时卡尔身上有三个无顺序的属性槽，他可以从三种属性中任意选择三个放入属性槽中，然后通过当前的属性组合召唤技能。每种不同的属性组合都可以为卡尔召唤出不同的技能，共有十种组合： 1、冰冰冰 2、冰冰火 3、冰冰雷 4、冰火火 5、冰火雷 6、冰雷雷 7、火火火 8、火火雷 9、火雷雷 10、雷雷雷 现在我们想继续加强卡尔，如果给卡尔四种属性：冰、火、雷、风，同时给卡尔四个无顺序的属性槽，从而让卡尔可以从四种属性中任意选择四个，则请问卡尔共可以召唤出多少种不同的技能？ 28 35 48 64 题解穷举法看到这道题首先想到的是：这是一道排列组合题，但是要包含判重操作。但是在数学上判重操作有点复杂，所以我先写个小程序穷举一下，得出正确结果。 穷举法的思路是这样的，我以三个元素为例子，假设冰对应数字0，火对应数字1，雷对应数字2，然后去构造一组高位至低位数字不严格递增的三进制数 冰冰冰-000 冰冰火-001 冰冰雷-002 冰火火-011 冰火雷-012 冰火火-022 火火火-111 火火雷-112 火雷雷-122 雷雷雷-222 将思路延展至四个元素，就可以假设冰对应数字0，火对应数字1，雷对应数字2，风对应数字3，去构造相对应的四进制数字。 12345678910111213141516let element = ['冰','火','雷','风',];let num = 3;let count = 0;for (var i1 = 0; i1 &lt;= num; i1++) &#123; for (var i2 = 0; i2 &lt;= num; i2++) &#123; for (var i3 = 0; i3 &lt;= num; i3++) &#123; for(var i4 = 0; i4&lt;=num;i4++)&#123; if (i1&lt;=i2&amp;&amp;i2&lt;=i3&amp;&amp;i3&lt;=i4) &#123; console.log(element[i1]+element[i2]+element[i3]+element[i4]); ++count; &#125; &#125; &#125; &#125;&#125;console.log('冰火雷风的总数: ',count); 因为懒，所以直接写了一个js，然后在控制台中： 1$ node bhlf.js 最后的结果如下： 123456789101112131415161718192021222324252627282930313233343536冰冰冰冰冰冰冰火冰冰冰雷冰冰冰风冰冰火火冰冰火雷冰冰火风冰冰雷雷冰冰雷风冰冰风风冰火火火冰火火雷冰火火风冰火雷雷冰火雷风冰火风风冰雷雷雷冰雷雷风冰雷风风冰风风风火火火火火火火雷火火火风火火雷雷火火雷风火火风风火雷雷雷火雷雷风火雷风风火风风风雷雷雷雷雷雷雷风雷雷风风雷风风风风风风风冰火雷风的总数: 35 数学解法解法一首先写出一种分类讨论的解法，这也是题解中常见的报告。将四个技能槽看作四个箱子，然后将冰、火、雷、风四个元素看作球，将球丢入四个箱子中，可以写出对应的公式为：$${ C }_{ 4 }^{ 1 }+{ C }_{ 4 }^{ 2 }{ C }_{ 2 }^{ 1 }+{ C }_{ 4 }^{ 2 }+{ C }_{ 4 }^{ 3 }{ C }_{ 3 }^{ 1 }+{ C }_{ 4 }^{ 4 }=35$$ 解法二但是上述解法要分类讨论，这里感谢yj童鞋给出的思路，将题目条件抽象为$$\begin{cases}a+b+c+d=4\\a,b,c,d\ge 0\\\end{cases}$$其中a,b,c,d分别为冰火雷风元素，每一个元素至少为0个，至多为4个，且四个元素的总和必为4。在这里使用一个技巧（便于分割），令A=a+1，B=b+1，C=c+1，D=d+1，则上述条件变为：$$\begin{cases}A+B+C+D=8\\A,B,C,D\ge 1\end{cases}$$上述问题可抽象为，共有八个球，需要将这八个球分为四组，那么就要在七个位置切三刀。则答案为：$${ C }_{ 7 }^{ 3 }=35$$举例说明，如下情况为1115，则说明冰火雷三元素均为0，风元素为4个球。 〇|〇|〇|〇〇〇〇〇 如下情况为2222，则说明冰火雷风四个元素个有一个球。 〇〇|〇〇|〇〇|〇〇 接着可以在冰火雷三元素上进行验证，同理条件可以抽象为$$\begin{cases}a+b+c=3\\a,b,c,d\ge 0\end{cases}$$运用技巧令A=a+1，B=b+1，C=c+1，上述条件变为：$$\begin{cases}A+B+C=6\\A,B,C\ge 1\end{cases}$$则三个球共可以切出${ C }_{ 5 }^{ 2 }=10​$个技能。 杨辉三角123456789 １ １ １ １ ２ １ １ ３ ３ １ １ ４ ６ ４ １ １ ５ 10 10 ５ １ １ ６ 15 20 15 ６ １ １ ７ 21 35 35 21 ７ １１ ８ 28 56 70 56 28 ８ １ 由杨辉三角的性质可知第n行的第 k 个数字为组合数${ C }_{ n-1 }^{ k-1 }​$，则看到第6行第3个数字为3个元素的解，第8行第4个数字为4个元素的解。]]></content>
      <categories>
        <category>笔试题</category>
      </categories>
      <tags>
        <tag>小米</tag>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo - Next 主题添加搜索功能]]></title>
    <url>%2F2019%2F03%2F10%2Fhexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[参考自Yaya’s blog添加Hexo搜索功能 安装相关插件首先安装搜索插件： hexo-generator-searchdb 在hexo路径文件夹下执行： 1$ npm install hexo-generator-searchdb --save 配置hexo安装完成，在hexo的配置文件_config.yml中添加： 12345search: path: search.xml field: post format: html limit: 10000 配置主题Next 主题自带搜索设置，编辑主题配置文件：_config.yml 找到文件中 Local search 的相关配置，设为 true 123# Local searchlocal_search: enable: true hexo 重新部署1$ hexo d -g]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的async/await浅析（一）]]></title>
    <url>%2F2019%2F03%2F09%2FJavaScript%E4%B8%AD%E7%9A%84async-await%E6%B5%85%E6%9E%90(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[async/await正式纳入ES7标准之中，给JavaScript的异步编程带来了许多的便利。首先介绍一下async/await的使用场景（大部分情况是由于promise链式带来的不便利）： 多个promise的then链，后续的步骤需要之前的每一个步骤的结果 在循环中需要异步获取数据，循环外异步设置状态 什么是promise从开头的场景就可以知道，使用async/await大部分情况是由于Promise在解决某些需求的时候力不从心了，那么我们就需要先了解Promise，这里是MDN的Promise定义和使用Promise，在理解Promise可以胜任的场景之后，再引入async/await的优点。 Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 Promise 本质上是一个绑定了回调的对象，而不是将回调传进函数内部。 首先我们设计一个业务场景，需求中task1从服务器异步获取数据，然后再传递给task2完成任务。代码如下： 12345678910function task1() &#123; setTimeout(() =&gt; console.log('task1 take too longtime'), 1000);&#125;function task2()&#123; console.log('this is task2');&#125;task1();task2(); 然而输出结果却如下： 12this is task2task1 take too longtime 如果在实际场景中，task2的参数就会为undefined，原因是由于task1是异步函数调用，那么我们如果想要这两个task顺序执行应该怎么办呢？在这里引入Promise的约定： 在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。 通过 .then 形式添加的回调函数，甚至都在异步操作完成之后才被添加的函数，都会被调用。 通过多次调用 .then，可以添加多个回调函数，它们会按照插入顺序并且独立运行。 从上述的约定可以看出，Promise最好的应用场景就是链式调用。 链式调用还是上一个业务场景，这次我们用Promise的then链来解决这个异步函数调用的问题： 12345678910111213141516function task1() &#123; return new Promise(resolve =&gt;&#123; setTimeout(() =&gt; &#123; console.log('task1 take too longtime'); resolve(); &#125;, 1000); &#125;)&#125;function task2()&#123; console.log('this is task2');&#125;task1().then(() =&gt; &#123; task2();&#125;); 最终结果如下： 12task1 take too longtimethis is task2 同时Promise可不是仅仅.then一次，所谓的链式调用即是可以形成一个then链，理论上可以一直then来将异步函数顺序地执行下去，如下面的业务场景共有三个任务，需要顺序执行，分别消耗100，200，300ms的时间： 123456789101112131415161718192021222324252627282930313233function task1(time) &#123; console.log(`task1 take $&#123;time&#125; ms`); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(), time); &#125;);&#125;function task2(time) &#123; console.log(`task2 take $&#123;time&#125; ms`); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(), time); &#125;);&#125;function task3(time) &#123; console.log(`task3 take $&#123;time&#125; ms`); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(), time); &#125;);&#125;function finalTask()&#123; console.time('finalTask'); const time1 = 100, time2 = 200, time3 = 300;//三个任务分别模拟100，200，300ms task1(time1) .then(()=&gt;task2(time2)) .then(()=&gt;task3(time3)) .then(()=&gt;&#123; console.timeEnd('finalTask'); &#125;)&#125;finalTask(); 最后的结果如下： 1234task1 take 100 mstask2 take 200 mstask3 take 300 msfinalTask: 626.755ms 可以看到三个任务是顺序执行的，并且消耗的时间与计时器的时间相差无几。 链式调用传参设计场景中一个常见的需求就是连续执行两个或者多个异步操作，并且每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。下面演示promise链式传递参数： 1234567891011121314151617function task1() &#123; return new Promise(resolve =&gt;&#123; setTimeout(() =&gt; &#123; console.log('task1 take too longtime'); resolve('this is task1 data'); &#125;, 1000); &#125;)&#125;function task2(data)&#123; console.log('this is task2'); console.log(data);&#125;task1().then((data) =&gt; &#123; task2(data);&#125;); 最后结果如下： 123task1 take too longtimethis is task2this is task1 data 可以看到任务1和2还是顺序执行的，并且在任务2中，拿到了任务1传递来的参数，这个参数通过任务1中的resolve函数传递给下一个异步函数。每一个 Promise 代表了链式中另一个异步过程的完成。 Catch的后续链式调用但是在很多场景中，可能存在需要catch error的情况，比如服务器宕机了，或者甚至服务器传来不正确的json数据（笔者就遇到了这种情况，json格式错误，但是前端可以通过字符串操作来纠正并解析数据，然而每次异步获取数据都会走catch）。在这种场景下，首先要明确一点，catch之后是可以继续链式调用promise的，同时catch中可以对数据处理并传递给下一个函数，代码如下： 12345678910111213141516new Promise((resolve, reject) =&gt; &#123; console.log('Initial'); resolve();&#125;).then(() =&gt; &#123; throw new Error('Something failed'); console.log('Do this');&#125;).catch(() =&gt; &#123; console.log('Do that'); return 'error text';&#125;).then((data) =&gt; &#123; console.log(data); console.log('Do this whatever happened before');&#125;); 最后的执行结果如下： 1234InitialDo thaterror textDo this whatever happened before 对这个结果进行分析，可以看出异步函数是链式顺序执行的，其中“Do this”方法中由于抛出一个Error，所以没有输出“Do this”。接着catch方法中正确执行，并且假设“error text”为处理后的结果，是可以顺利传递给下一个方法的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的async/await浅析（二）]]></title>
    <url>%2F2019%2F03%2F09%2FJavaScript%E4%B8%AD%E7%9A%84async-await%E6%B5%85%E6%9E%90(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[在上一篇的文章中已经简单介绍了promise的使用方法和then链的情况，但是还有一些状态下promise会力不从心： 在循环中需要异步获取数据，循环外获取数据 多个promise的then链，后续的步骤需要之前的每一个步骤的结果 promise的不足我在实际业务操作的时候，初期一直遇到一个困惑，我已经学会了如何使用promise链，但是却无法解决在一个循环中异步获取每一个item，并且要保证他们的遍历次序，最后在循环外setState。以及我无法在链式中的后续步骤获取之前每一步的操作结果。接着我将举例说明这些情况产生的场景，并提出我当前的解决方案。 循环异步获取数据在这里假设有一个list数组，每一个item是这个任务的id，名称和执行时间。需要对该数组遍历，每一个遍历操作是异步函数，我把每一个item的执行时间刻意设置成不同时长，期待数组遍历时以id递增的次序读取每一个item。 12345678910111213141516let content = [&#123;id:1,name:'task1',time:200&#125;,&#123;id:2,name:'task2',time:300&#125;,&#123;id:3,name:'task3',time:100&#125;];function getData(item)&#123; return new Promise(resolve =&gt; &#123; setTimeout(()=&gt;&#123; console.log(item); resolve(); &#125;,item.time); &#125;)&#125;content.map((item)=&gt;&#123; getData(item);&#125;);console.log('I wanna result'); 下面看一下测试效果： 1234I wanna result&#123; id: 3, name: &apos;task3&apos;, time: 100 &#125;&#123; id: 1, name: &apos;task1&apos;, time: 200 &#125;&#123; id: 2, name: &apos;task2&apos;, time: 300 &#125; 可以看到结果很不幸，读取到的item并不是以id递增的次序顺序输出的，而是以异步函数执行所需的时间打印出来的，并且期待的最终结果最先执行。那么我是否可以使用promise么？答案是可以的，但是我之后再另一篇文章中对此情况进行说明，在这里我们先解释使用async/await解决该场景。 在这个需求场景中，之前我一直使用的promise链无法发挥其作用了。原因很简单，我需要在循环中使用then来处理这个问题，但是我不知道应该加在哪里。并且最终结果也需要在循环结束的时候，加在then的最后。在阐述完promise链的第二个不足后，我再一起提出解决方案。 获取每一步结果在这个需求场景中，我们设计一个问题，我们需要执行三个任务，这三个任务是异步函数，但是在第三个任务执行的时候，需要用到前两个函数的执行结果。拿到前一个执行结果很简单，但是如果想要获取到的一个函数的执行结果，就需要将第一个函数的执行结果添加到第二个函数传递给第三个函数的结果中。在这里我直接字符串连接，最后结果可以通过截取逗号来得到每一个结果。除了字符串连接还可以将每一步结果push到数组中，然后把数据数组在then链中传递。 123456789101112131415161718192021222324function task1() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('result1'), 100); &#125;);&#125;function task2(data) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(`$&#123;data&#125;,result2`), 200); &#125;);&#125;function task3(data) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(`$&#123;data&#125;,result3`), 300); &#125;);&#125;task1().then((data)=&gt;task2(data)).then((data)=&gt;task3(data)).then((data)=&gt;&#123; console.log(data);&#125;) 下面是最后的结果，这是第三个任务中的异步函数获取到的最后结果，可以通过逗号将字符串切割获取到每一步的结果。 1result1,result2,result3 async/await介绍在这里可以先看一下阮一峰老师的介绍，然后在下面我给出我的一些理解。 异步I/O不就是读取一个文件吗，干嘛要搞得这么复杂？异步编程的最高境界，就是根本不用关心它是不是异步。 我们从最开始的问题入手，我们遇到了什么问题？一个变量初始化—&gt;异步读取服务器数据—&gt;修改变量。但是在这个过程中，由于异步方法的存在，使得我们往往先执行了修改变量的操作，后从服务器获取到了数据。那么，我们是不是可以用一种方法，让我们可以不用去关心一个方法是不是异步函数，但是可以很轻松的去异步编程呢？async/await就提供了这样一个解决方案。 什么是async/await async用于将一个函数申明为异步函数 await用于等待一个异步函数的执行完成，即通过await来调用一个async函数 且根据语法规定：await只能出现在async函数中 什么是async先通过一个测试程序来输出async申明的函数： 1234async function getData()&#123; return 'what is async';&#125;console.log(getData()); 最后控制台输出如下： 1Promise &#123; &apos;what is async&apos; &#125; 通过这个例子就可以明白，原来用async申明的函数，最后也是返回一个promise啊！那么我们依旧可以使用then链来让异步函数按自己想要的顺序执行，如下： 1234async function getData()&#123; return 'what is async';&#125;getData().then((data)=&gt;&#123;console.log(data)&#125;); 我们通过then链把这个异步函数的结果输出出来，可以看到async申明的函数，本质上就是一个异步函数，也可以使用then来获取到结果 1what is async 什么是await我们只有将async和await组合使用，才可以看出async/await比promise更加优秀的地方。首先先看一下await如何使用，如下是样例程序： 12345678async function getData()&#123; return 'what is async';&#125;async function test()&#123; let temp = await getData(); console.log(temp);&#125;test(); 最后结果和在then里获取promise结果一致： 1what is async 但是！可以看出来let temp = await getData();这一条语句，在使用的时候，已经和平时编程习惯相差无几了。那么我们来看一看，如何解决文章开头promise的问题。 async/await解决方案循环异步获取数据这是文章开头的问题，这里重述一遍。这里假设有一个list数组，每一个item是这个任务的id，名称和执行时间。需要对该数组遍历，每一个遍历操作是异步函数，我把每一个item的执行时间刻意设置成不同时长，期待数组遍历时以id递增的次序读取每一个item。 但是我们这次，使用async/await来重写这个场景，不使用then，预期结果为：三个任务task按照id递增顺序输出，三个任务执行完成后，最终结果才输出。 12345678910111213141516171819let content = [&#123;id:1,name:'task1',time:200&#125;,&#123;id:2,name:'task2',time:300&#125;,&#123;id:3,name:'task3',time:100&#125;];function getData(item)&#123; return new Promise(resolve =&gt; &#123; setTimeout(()=&gt;&#123; console.log(item); resolve(); &#125;,item.time); &#125;)&#125;async function test()&#123; for (let item of content) &#123; let temp = await getData(item); &#125; console.log('I wanna result');&#125;test(); 可以看出，使用async和await不仅可以写出类似于适应平时编程习惯的写法，而且还可以满足场景需求。 1234&#123; id: 1, name: &apos;task1&apos;, time: 200 &#125;&#123; id: 2, name: &apos;task2&apos;, time: 300 &#125;&#123; id: 3, name: &apos;task3&apos;, time: 100 &#125;I wanna result 但是这个场景中有一个问题存在，由于forEach和map这两种写法，会要求在遍历中使用一个函数，而await必须要存在于async申明的函数中。所以await在这两种循环中是无法胜任的，请尽量使用没有内部函数的循环。 获取每一步结果重述一遍文章开头的场景：在这个需求场景中，我们设计一个问题，我们需要执行三个任务，这三个任务是异步函数，但是在第三个任务执行的时候，需要用到前两个函数的执行结果。这里我们改写用async/await的写法： 12345678910111213141516171819202122232425262728function task1() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve('result1'), 100); &#125;);&#125;function task2() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(`result2`), 200); &#125;);&#125;function task3() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(`result3`), 300); &#125;);&#125;async function test()&#123; let task1Data = await task1(); let task2Data = await task2(); let task3Data = await task3(); console.log('task1Data: ',task1Data); console.log('task2Data: ',task2Data); console.log('task3Data: ',task3Data);&#125;test(); 从结果可以看到，三个任务是依次执行的，而且保存在了各自的变量申明之中，在后续的步骤中，可以在任意位置来调用读取异步函数的结果： 123task1Data: result1task2Data: result2task3Data: result3 await结合then（记于3月27日新的心得） await和then链也是可以结合使用的，例如当我需要从异步函数获取到的对象中，再进行解析获取到特定属性。 1234567891011let data = &#123;content:"test",id:1&#125;;function get()&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;resolve(data),5000); &#125;)&#125;async function test()&#123; let card = await get().then(data=&gt;&#123;return data.content&#125;); console.log(card);&#125;test(); 结果是： 1测试结果 参考文献 边城老师的理解 JavaScript 的 async/await 阮一峰老师的async 函数的含义和用法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio常用快捷键]]></title>
    <url>%2F2016%2F05%2F25%2FAndroid%20Studio%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[最近开始尝试转向Android Studio开发了，于是总结一下常用的快捷键。顺带着粘一段wikipedia上as的简介凑字数。 Android Studio是一个为Android平台开发程序的集成开发环境。2013年5月16日在Google I/O上发布，可供开发者免费使用。2013年5月发布早期预览版本，版本号为0.1。2014年6月发布0.8版本，至此进入beta阶段。第一个稳定版本1.0于2014年12月8日发布。Android Studio基于JetBrains IntelliJ IDEA，为Android开发特殊定制，并在Windows、OS X和Linux平台上均可运行。 本篇适用于日常使用，详细快捷键请参考此篇AndroidStudio快捷键汇总 重构-重命名 Shift + F6这个很重要 提取局部变量 Ctrl(Command) + Alt(Option) + V 提取全局变量 Ctrl(Command) + Alt(Option) + F 快速修复 Alt(Option) + Enter(用于类型强转等快速修复，不可以用于提取全局变量，和eclipse不一样) 全屏当前标签页 Ctrl(Command) + Shift + F12 撤销(undo) Ctrl(Command) + Z 重做(redo) Ctrl(Command) + Shift + Z 格式化代码 Ctrl(Command) + Alt(Option) + L 折叠代码 Ctrl(Command) + . 方法参数提示 Ctrl(Command) + P 显示注释文档 Ctrl(Command) + Q 生成构造器、Getter、Setter Alt(Option) + Insert 块选中 Alt(Option) + J（解放Ctrl(Command) + LEFT/RIGHT的福音） 自动代码 Ctrl(Command) + J 查询当前元素在工程中的引用 Alt(Option) + F7 方法间快速跳转 Alt(Option) + UP(DOWN) 标签页间相互跳转 Alt(Option) + LEFT(RIGHT) 重写方法 Ctrl(Command) + O 代码上下移动 Alt(Option) + Shift + UP(DOWN) 打开设置对话框 Ctrl(Command) + Alt(Option) + S 打开当前项目/模块属性 Ctrl(Command) + Shift + Alt(Option) + S 多行编辑 Alt + 鼠标滑选]]></content>
      <categories>
        <category>Android Studio</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析WinDLX及其实战]]></title>
    <url>%2F2016%2F04%2F23%2F%E6%B5%85%E6%9E%90WinDLX%E5%8F%8A%E5%85%B6%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[WinDLX简介 WinDLX模拟器是一个基于Windows操作系统的图形化、交互式DLX指令集模拟器，能够演示DLX指令集流水线是如何工作的。该模拟器可以装载DLX汇编语言程序（后缀为“.s”的文件），然后单步、设断点或是连续执行该程序。CPU的寄存器、流水线、I/O和存储器都用图形进行表示，以形象生动的方式描述DLX流水线的工作过程。模拟器还提供了对流水线操作的统计功能，便于对流水线进行性能分析。 环境配置 主要运行在win3.0上，16bit软件，不支持64bit系统。所以在使用前需要确保系统环境为32bit，方可兼容此软件，否则需要虚拟机环境。 为WinDLX创建目录，例如D:\WINDLX，注意受编译的约束，路径名中不可以包含汉字。 解压WinDLX软件包或拷贝所有的WinDLX文件（至少包含 windlx.exe，windlx.hlp，fact.s 和input.s ）到这个WinDLX 目录。 WinDLX子窗口Pipeline IF取指阶段 ID译码阶段 MEM访存阶段 WB写回阶段 intEX整型加阶段执行 faddEX浮点加执行阶段 fmul浮点乘执行阶段 fdivEX浮点除执行阶段 Code 三栏信息，从左到右依次为：地址 (符号或数字)、命令的十六进制机器代码和汇编命令。 按下 F7 键，模拟就向前执行一步，第一行的颜色变成黄色，下一行变成棕色，依次向下执行。 Clock Cycle Diagram 横坐标代表时钟周期，纵坐标为指令集 Breakpoint 此为增设断点的子窗口 Register 此为寄存器的子窗口 Statistics 分析窗口，主要关注RAW stall数据相关，Structral stall结构相关，Control stall控制相关。 下文中会主要分析这三者的产生原因及其消除方法。 WinDLX指令分类 Load/Store指令：除R0之外，所有通用寄存器与浮点寄存器都可以作为加载或存储之用 ALU操作指令：所有的ALU操作都是寄存器–寄存器指令。加，减，与，或，异或，移位，比较指令比较两个寄存器(=, !=, &lt;, &gt;, =&lt;, =&gt;)，如果条件为真，则在目标寄存器置1，否则置0。 分支/跳转指令：所有分支都是条件分支，分支条件由指令测试寄存器为零或非零来指定。 浮点运算指令：浮点加，减，乘，除(浮点格式为IEEE754) Trap机制 Trap在DLX程序和系统I/O之间建立了接口。在WinDLX中共定义了5种Trap。 0对于Trap指令来说是无效参数，Trap 0用来结束程序 Trap 1可以为读写打开一个文件，打开的文件在DLX重置或结束之后自动关闭 Trap 2关闭由Trap 1打开的文件 Trap 3从文件块读，读入一个文件块或者标准输入的一行 Trap 4向文件块写，向文存储器或标准输出块写 实例讲解程序说明功能：卡特兰数求解输入：输入一个大于0的自然数n，程序会计算第n项的卡特兰数 测试用例： 输入:n=7 输出：132 卡特兰数讲解 一般公式 $$ C_n = \frac{1}{n+1} \dbinom{2n}{n} = \frac{(2n)!}{(n+1)!n!} $$ 递推公式 它也满足 卡塔兰数的渐近增长为 前20项为（OEIS中的数列A000108）：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190 样例程序求解第n项卡特兰数的WinDLX样例程序 ;*********** WINDLX Ex.3: Factorial ************* ;*********** (c) 1991 Günther Raidl ************* ;*********** Modified: 1992 Maziar Khosravipour ************* ; class: ; number: ; author: ;-------------------------------------------------------------------------- ; Program begin at symbol main ; requires module INPUT ; read a number from stdin and calculate the catalan number (type: double) ; the result is written to stdout ;-------------------------------------------------------------------------- .data Prompt: .asciiz &quot;An integer value &gt;1 : &quot; PrintfFormat: .asciiz &quot;Factorial = %g\n\n&quot; .align 2 PrintfPar: .word PrintfFormat PrintfValue: .space 1024 .text .global main main: ;*** Read value from stdin into R1 addi r1,r0,Prompt jal InputUnsigned ;*** init values subi r1,r1,1 movi2fp f10,r1 ;R1 -&gt; D0 D0..Count register cvti2d f0,f10 addi r2,r0,1 ;1 -&gt; D2 D2..result movi2fp f11,r2 cvti2d f2,f11 movd f4,f2 ;1-&gt; D4 D4..Constant 1 addd f6,f0,f4 ;D0+1 -&gt; D6 addd f8,f0,f0 ;2*D0 -&gt; D8 addi r2,r0,1 ;1 -&gt; D10 D10..result movi2fp f11,r2 cvti2d f10,f11 ;*** Break loop if D0 = 1 Loop1: led f0,f4 ;D0&lt;=1 ? bfpt Loop2 ;*** Multiplication and next loop1 multd f2,f2,f0 subd f0,f0,f4 j Loop1 ;*** Break loop if D8 = 1 Loop2: led f8,f4 ;D8&lt;=1 ? bfpt Finish ;*** Multiplication and next loop2 multd f10,f10,f8 subd f8,f8,f4 ;multd f10,f10,f8 ;subd f8,f8,f4 ;multd f10,f10,f8 ;subd f8,f8,f4 ;multd f10,f10,f8 ;subd f8,f8,f4 j Loop2 Finish: ;*** write result to stdout multd f2,f2,f2 multd f6,f6,f2 divd f10,f10,f6 sd PrintfValue,f10 addi r14,r0,PrintfPar trap 5 ;*** end trap 0 三种相关 数据相关：当一条指令需要用到前面指令的执行结果，而这些指令均在流水线中重叠执行时 结构相关：当指令在重叠执行过程中，硬件资源满足不了指令重叠执行的要求,发生资源冲突时 控制相关：当不满足条件时或者其他改变PC值的跳转指令，通常发生控制相关 消除方法 数据相关：勾选Enable Forwading，采用重定向技术 结构相关：通过增加硬件的数目来解决结构相关 控制相关：为了解决控制相关，我们要在分支跳转指令里循环展开，通过代码的冗余来做到消除控制相关]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>WinDLX</tag>
        <tag>指令集流水线</tag>
      </tags>
  </entry>
</search>
